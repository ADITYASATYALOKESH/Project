<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Operating System</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header class="topnav">
    <div class="logo">Data Structures and Algorithms</div>
    <nav>
      <a href="index.html">Dashboard</a>
      <a href="menu.html">Menu</a>
      <a href="index.html">Home</a>
    </nav>
  </header>

  <div class="layout">
    <aside class="sidebar">
      <h2>Topics</h2>
      <ul>
        <li class="topp"><a href="index.html">Introduction</a></li>
        <li><a href="type1.html">Arrays</a></li>
        <li><a href="type2.html">Strings</a></li>
        <li><a href="type3.html">Linked List</a></li>
        <li><a href="type4.html">Stack</a></li>
        <li>
            <a href="type5.html">Queue</a>
        </li>
        <li>
            <a href="type6.html">Tree</a>
        </li>
        <li>
            <a href="type7.html">Graph</a>
        </li>
        <li>
            <a href="type8.html">Dynamic Programming</a>
        </li>
      </ul>
    </aside>

    <main class="content">
      <h2>Graph Algorithms</h2>
      <p>
        Graph algorithms are methods used to manipulate and analyze graphs, solving various range of problems like finding the shortest path, cycles detection.
      </p>
      <h3>Graph and its representations</h3>
      <p>
        A Graph is a non-linear data structure consisting of vertices and edges. The vertices are sometimes also referred to as nodes and the edges are lines or arcs that connect any two nodes in the graph. More formally a Graph is composed of a set of vertices( V ) and a set of edges( E ). The graph is denoted by G(V, E).
      </p>
      <h3>Representation of Graph</h3>
      <p>
        Here are the two most common ways to represent a graph : For simplicity, we are going to consider only unweighted graphs in this post.
      </p>
      <ol>
        <li>Adjacency Matrix</li>
        <li>
            Adjacency List
        </li>
      </ol>
      <h3>Adjacency Matrix Representation</h3>
      <p>
        An adjacency matrix is a way of representing a graph as a matrix of boolean (0's and 1's)
      </p>
      <p>
        Let's assume there are n vertices in the graph So, create a 2D matrix adjMat[n][n] having dimension n x n.
      </p>
      <ul>
        <li>
            If there is an edge from vertex i to j, mark adjMat[i][j] as 1. 
        </li>
        <li>
            If there is no edge from vertex i to j, mark adjMat[i][j] as 0.
        </li>
      </ul>
      <h2>Representation of Undirected Graph as Adjacency Matrix:</h2>
      <p>
        The below figure shows an undirected graph. Initially, the entire Matrix is ​​initialized to 0. If there is an edge from source to destination, we insert 1 to both cases (adjMat[source][destination] and adjMat[destination][source]) because we can go either way.
      </p>
      <img src="./undirected_graph_matrix.png" alt="Undirected Graph as Matrix">
      <pre>
        code in c++
        -----------
        // C++ program to demonstrate Adjacency Matrix
        // representation of undirected and unweighted graph
        #include <bits/stdc++.h>
        using namespace std;

        void addEdge(vector<vector<int>> &mat, int i, int j)
        {
            mat[i][j] = 1;
            mat[j][i] = 1; // Since the graph is undirected
        }

        void displayMatrix(vector<vector<int>> &mat)
        {
            int V = mat.size();
            for (int i = 0; i < V; i++)
            {
                for (int j = 0; j < V; j++)
                    cout << mat[i][j] << " ";
                cout << endl;
            }
        }

        int main()
        {

            // Create a graph with 4 vertices and no edges
            // Note that all values are initialized as 0
            int V = 4;
            vector<vector<int>> mat(V, vector<int>(V, 0));

            // Now add edges one by one
            addEdge(mat, 0, 1);
            addEdge(mat, 0, 2);
            addEdge(mat, 1, 2);
            addEdge(mat, 2, 3);

            /* Alternatively we can also create using below
              code if we know all edges in advacem

            vector<vector<int>> mat = {{ 0, 1, 0, 0 },
                                      { 1, 0, 1, 0 },
                                      { 0, 1, 0, 1 },
                                      { 0, 0, 1, 0 } }; */

            cout << "Adjacency Matrix Representation" << endl;
            displayMatrix(mat);

            return 0;
        }
      </pre>
      <h3>
        Output
      </h3>
      <pre>
        Adjacency Matrix Representation
        0 1 1 0 
        1 0 1 0 
        1 1 0 1 
        0 0 1 0 
      </pre>
      <h2>
        Representation of Directed Graph as Adjacency Matrix:
      </h2>
      <p>
        The below figure shows a directed graph. Initially, the entire Matrix is ​​initialized to 0. If there is an edge from source to destination, we insert 1 for that particular adjMat[source][destination].
      </p>
      <img src="./directed_graph_matrix.png" alt="Directed graph as Matrix Representation">
      <h2>
        Adjacency List Representation
      </h2>
      <p>
        An array of Lists is used to store edges between two vertices. The size of array is equal to the number of vertices (i.e, n). Each index in this array represents a specific vertex in the graph. The entry at the index i of the array contains a linked list containing the vertices that are adjacent to vertex i.
      </p>
      <p>
        Let's assume there are n vertices in the graph So, create an array of list of size n as adjList[n].
      </p>
      <ul>
        <li>
          adjList[0] will have all the nodes which are connected (neighbour) to vertex 0.
        </li>
        <li>
          adjList[1] will have all the nodes which are connected (neighbour) to vertex 1 and so on.
        </li>
      </ul>
      <h2>
        Representation of Undirected Graph as Adjacency list:
      </h2>
      <p>
        The below undirected graph has 3 vertices. So, an array of list will be created of size 3, where each indices represent the vertices. Now, vertex 0 has two neighbours (i.e, 1 and 2). So, insert vertex 1 and 2 at indices 0 of array. Similarly, For vertex 1, it has two neighbour (i.e, 2 and 0) So, insert vertices 2 and 0 at indices 1 of array. Similarly, for vertex 2, insert its neighbours in array of list.
      </p>
      <img src="./undirected_graph_list.png" alt="Undirected Graph using List">
      <pre>
        code in c++
        -----------
        #include <iostream>
        #include <vector>
        using namespace std;

        // Function to add an edge between two vertices
        void addEdge(vector<vector<int>>& adj, int i, int j) {
            adj[i].push_back(j);
            adj[j].push_back(i); // Undirected
        }

        // Function to display the adjacency list
        void displayAdjList(const vector<vector<int>>& adj) {
            for (int i = 0; i < adj.size(); i++) {
                cout << i << ": "; // Print the vertex
                for (int j : adj[i]) {
                    cout << j << " "; // Print its adjacent
                }
                cout << endl; 
            }
        }

        // Main function
        int main() {
            // Create a graph with 4 vertices and no edges
            int V = 4;
            vector<vector<int>> adj(V); 

            // Now add edges one by one
            addEdge(adj, 0, 1);
            addEdge(adj, 0, 2);
            addEdge(adj, 1, 2);
            addEdge(adj, 2, 3);

            cout << "Adjacency List Representation:" << endl;
            displayAdjList(adj);

            return 0;
        }
      </pre>
      <h3>
        Output
      </h3>
      <pre>
        Adjacency List Representation:
        0: 1 2 
        1: 0 2 
        2: 0 1 3 
        3: 2 
      </pre>
      <h2>Most Popular Problems On Graph</h2>
      <ul>
        <li>
          <a href="">Clone Graph</a>
        </li>
        <li>
          <a href="">All Paths From Source to Target</a>
        </li>
        <li>
          <a href="">Is Graph Bipartite?</a>
        </li>
        <li>
          <a href="">Course Schedule</a>
        </li>
      </ul>
    </main>
  </div>
</body>
</html>